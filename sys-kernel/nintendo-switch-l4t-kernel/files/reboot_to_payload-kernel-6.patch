From 43b8bd5d7173d43fa63b8cea792dd44ba1f40ae1 Mon Sep 17 00:00:00 2001
From: Ezekiel Bethel <zek@9net.org>
Date: Sun, 11 Aug 2019 20:52:16 +0100
Subject: [PATCH] reboot2payload: add payload selection via sysfs

---
 drivers/soc/tegra/pmc-reboot2payload.c | 149 ++++++++++++++++++++-----
 drivers/soc/tegra/pmc.c                |  11 ++
 2 files changed, 131 insertions(+), 29 deletions(-)

diff --git a/drivers/soc/tegra/pmc-reboot2payload.c b/drivers/soc/tegra/pmc-reboot2payload.c
index c1979b4f547f..26558fbd82e2 100644
--- a/drivers/soc/tegra/pmc-reboot2payload.c
+++ b/drivers/soc/tegra/pmc-reboot2payload.c
@@ -3,6 +3,7 @@
 #include <linux/of_address.h>
 #include <linux/of_platform.h>
 #include <linux/firmware.h>
+#include <linux/uaccess.h>
 
 #define NR_SMC_REGS		6
 
@@ -33,11 +34,22 @@ static void send_smc(u32 func, struct pmc_smc_regs *regs)
 }
 
 #define ATMOSPHERE_COPY_TO_IRAM_COMMAND_ID    0xC2FFFE02
-#define ATMOSPHERE_DO_REBOOT_COMMAND_ID     0xC2FFFE03
+#define ATMOSPHERE_REBOOT_CONFIG_COMMAND_ID     0xC2FFFE03
+
+#define IRAM_CHUNK_SIZE 0x4000
+struct platform_device *r2p_device = NULL;
+
+const char *reboot_action = NULL;
+const char *default_reboot_payload_name = NULL;
+char custom_reboot_payload_name[128];
+
+const u32 iram_payload_base = 0x40010000;
+static u8 iram_write_buff[IRAM_CHUNK_SIZE];
 
 u32 ams_iram_copy(void *dram_addr, uint64_t iram_addr, uint32_t size, uint32_t flag)
 {
 	struct pmc_smc_regs regs;
+	printk("ams_iram_copy %p %08llx %04x %i\n", dram_addr, iram_addr, size, flag);
 	regs.args[0] = virt_to_phys(dram_addr);
 	regs.args[1] = iram_addr;
 	regs.args[2] = size;
@@ -48,32 +60,22 @@ u32 ams_iram_copy(void *dram_addr, uint64_t iram_addr, uint32_t size, uint32_t f
 	return (u32)regs.args[0];
 }
 
-u32 ams_reboot_to_payload(void)
-{
-	struct pmc_smc_regs regs;
-	regs.args[0] = 0;
-	regs.args[1] = 0;
-	regs.args[2] = 0;
-	regs.args[3] = 0;
-	regs.args[4] = 0;
-	regs.args[5] = 0;
-	send_smc(ATMOSPHERE_DO_REBOOT_COMMAND_ID, &regs);
-	return (u32)regs.args[0];
-}
-
-#define IRAM_CHUNK_SIZE 0x4000
-
-static u8 iram_write_buff[IRAM_CHUNK_SIZE];
-
-static int reboot_to_payload_driver_probe(struct platform_device *pdev)
+int ams_load_payload(const char *payload_fw_name)
 {
 	const struct firmware *reboot_payload_fw;
-	const u32 iram_payload_base = 0x40010000;
+	
 	size_t i, size_remaining, copy_size;
+	struct device *reboot_device = NULL;
+	reboot_device = &r2p_device->dev;
+	
+	/*reboot_device = bus_find_device_by_name(&platform_bus_type, NULL, "tegra-reboot2payload");
+	if(reboot_device == NULL)
+	{
+		printk(":( ok\n");
+		return 0;
+	}*/
 
-	// switch: send reboot payload. Should this actually be in pmc?
-
-	if(request_firmware_direct(&reboot_payload_fw, "reboot_payload.fw", &pdev->dev) == 0)
+	if(request_firmware_direct(&reboot_payload_fw, payload_fw_name, reboot_device) == 0)
 	{
 		size_remaining = reboot_payload_fw->size;
 		for(i = 0; i < reboot_payload_fw->size; i+=IRAM_CHUNK_SIZE,size_remaining-=IRAM_CHUNK_SIZE)
@@ -82,23 +84,112 @@ static int reboot_to_payload_driver_probe(struct platform_device *pdev)
 			memcpy(iram_write_buff, reboot_payload_fw->data + i, copy_size);
 			ams_iram_copy(iram_write_buff, iram_payload_base + i, IRAM_CHUNK_SIZE, 0);
 		}
+
+		release_firmware(reboot_payload_fw);
+		return 0;
 	}
 	else
 	{
-		dev_err(&pdev->dev, "Failed to load firmware :(");
+		dev_err(reboot_device, "request firmware failed :(\n");
+		return -1;
+	}
+}
+
+#define BOOT_CFG_AUTOBOOT_EN (1 << 0)
+#define BOOT_CFG_FROM_LAUNCH (1 << 1)
+#define BOOT_CFG_SEPT_RUN    (1 << 7)
+
+#define EXTRA_CFG_KEYS    (1 << 0)
+#define EXTRA_CFG_PAYLOAD (1 << 1)
+#define EXTRA_CFG_MODULE  (1 << 2)
+
+typedef struct __attribute__((__packed__)) _boot_cfg_t
+{
+    u8  boot_cfg;
+    u8  autoboot;
+    u8  autoboot_list;
+    u8  extra_cfg;
+    u8  rsvd[128];
+} boot_cfg_t;
+
+int ams_load_payload_for_reboot_reason(const char *cmd)
+{
+	int result;
+	boot_cfg_t hekate_config;
+
+	memset(&hekate_config, 0, sizeof(boot_cfg_t));
+
+	if(cmd != NULL && strcmp(cmd, "payload") == 0)
+	{
+		// Don't load hekate config for custom payloads.
+		return ams_load_payload(custom_reboot_payload_name);
 	}
+
+	result = ams_load_payload(default_reboot_payload_name);
+	if(result) return result;
+
+	if(cmd == NULL || strcmp(cmd, "recovery") == 0)
+	{
+		hekate_config.boot_cfg = BOOT_CFG_AUTOBOOT_EN;// | BOOT_CFG_FROM_LAUNCH;
+		hekate_config.autoboot = 1;
+		hekate_config.autoboot_list = 1;
+		//hekate_config.extra_cfg = EXTRA_CFG_PAYLOAD;
+	}
+
+	// Write Hekate config.
+	ams_iram_copy(&hekate_config, iram_payload_base + 0x94, sizeof(boot_cfg_t), 0);
+	return 0;
+}
+
+bool ams_should_r2p_for_reboot_reason(const char *cmd)
+{
+	if(cmd == NULL)
+	{
+		if(strcmp(reboot_action, "payload") == 0)
+		{
+			return true;
+		}
+	}
+	else if(strcmp(cmd, "normal") != 0)
+	{
+		return true;
+	}
+
+	return false;
+}
+
+static int reboot_to_payload_driver_probe(struct platform_device *pdev)
+{
+	struct device_node *node = pdev->dev.of_node;
+	int len;
+
+	r2p_device = pdev;
+
+	default_reboot_payload_name = of_get_property(node, "default-payload", &len);
+	reboot_action = of_get_property(node, "normal-reboot-action", &len);
+
 	return 0;
 }
 
-ssize_t reboot_sysfs_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+static ssize_t payload_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
 {
-	ams_reboot_to_payload();
-	return 1;
+	if(count > sizeof(custom_reboot_payload_name)-1) return -EINVAL;
+
+	if(copy_from_user(custom_reboot_payload_name, buf, count) == 0)
+	{
+		custom_reboot_payload_name[count] = 0;
+	}
+	else
+	{
+		return -EINVAL;
+	}
+
+	return count;
 }
 
-static struct device_attribute reboot_sysfs = __ATTR_WO(reboot_sysfs);
+static struct device_attribute payload_sysfs = __ATTR_WO(payload);
 static struct attribute *attrs[] = {
-    &reboot_sysfs.attr,
+    &payload_sysfs.attr,
     NULL,
 };
 static struct attribute_group attr_group = {
diff --git a/drivers/soc/tegra/pmc.c b/drivers/soc/tegra/pmc.c
index c54a98203970..ed205fc62ab3 100644
--- a/drivers/soc/tegra/pmc.c
+++ b/drivers/soc/tegra/pmc.c
@@ -982,6 +982,9 @@ enum tegra_system_reset_level tegra_pmc_get_system_reset_level(void)
 	return tegra_rst_lvl_sts;
 }
 
+extern bool ams_should_r2p_for_reboot_reason(const char *cmd);
+extern int ams_load_payload_for_reboot_reason(const char *cmd);
+
 static void tegra_pmc_program_reboot_reason(const char *cmd)
 {
 	u32 value;
@@ -1003,6 +1006,14 @@ static void tegra_pmc_program_reboot_reason(const char *cmd)
 			value |= PMC_SCRATCH0_MODE_PAYLOAD;
 	}
 
+	if(ams_should_r2p_for_reboot_reason(cmd))
+	{
+		if(ams_load_payload_for_reboot_reason(cmd) == 0)
+		{
+			value |= PMC_SCRATCH0_MODE_PAYLOAD;
+		}
+	}
+
 	tegra_pmc_reg_writel(value, TEGRA_PMC_SCRATCH0);
 }
 
-- 
2.21.0

